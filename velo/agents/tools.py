from logging import Logger
from typing import Any
from pydantic import ValidationError
from velo.db.services.artifact import ArtifactService, CreateArtifact
from velo.db.services.task import TaskService, CreateTask
from velo.types.agent import (
    Function,
    Parameters,
    Property,
    Tool,
    ToolCall,
    Message,
    AudienceResearchOut,
    ContentGenOut,
    ScheduleGenOut
)


GET_WEATHER = Tool(
    type="function",
    function=Function(
        name="weather_api",
        description="fetch the temperature of a city in degrees celsius",
        parameters=Parameters(
            type="object",
            properties={
                "city": Property(
                    type="string",
                    description="name of the city to check weather conditions"
                )
            },
            required=["city"]
        )
    )
)

URL_CALLER = Tool(
    type="function",
    function=Function(
        name="url_caller",
        description="use python request module to make a get \
            request using the url provided and return a string \
            of the JSON response",
        parameters=Parameters(
            type="object",
            properties={
                "url": Property(
                    type="string",
                    description="url or link to be fetched from the internet"
                )
            },
            required=["url"]
        )
    )
)

AUDIENCE_TOOL = Tool(
    type="function",
    function=Function(
        name="audience_agent",
        description="carries out auduence research to create audience profile \
            with an output containing lists of keywords, interests and pain \
            points to inform content generation",
        parameters=Parameters(
            type="object",
            properties={
                "prompt": Property(
                    type="string",
                    description="prompt to the audience research agent \
                        describing the context of the ad campaign being \
                        worked on"
                )
            },
            required=["prompt"]
        )
    )
)

CONTENT_TOOL = Tool(
    type="function",
    function=Function(
        name="content_agent",
        description="generates ad copies for different channels \
            based on the results from audience profiling with \
            an output containing lists of ad_copies, emails and \
            social media posts",
        parameters=Parameters(
            type="object",
            properties={
                "prompt": Property(
                    type="string",
                    description="prompt to the content generation agent \
                        describing the context of the ad campaign being \
                        worked on"
                ),
                "keywords": Property(
                    type="array",
                    items={
                        "type": "string"
                    },
                    description="keywords generated by audience agent"
                ),
                "interests": Property(
                    type="array",
                    items={
                        "type": "string"
                    },
                    description="interests generated by audience agent"
                ),
                "pain_points": Property(
                    type="array",
                    items={
                        "type": "string"
                    },
                    description="pain points generated by audience agent"
                )
            },
            required=["prompt", "keywords", "interests", "pain_points"]
        )
    )
)

SCHEDULER_TOOL = Tool(
    type="function",
    function=Function(
        name="scheduler_agent",
        description="generates content delivery schedule for different \
            channels based on the results from content generation. \
            It returns output containing mappings of platfrom, datetime and \
            content_ref for each ad_copy, email and social media post",
        parameters=Parameters(
            type="object",
            properties={
                "prompt": Property(
                    type="string",
                    description="prompt to the scheduler agent \
                        describing the context of the ad campaign being \
                        worked on"
                ),
                "ad_copies": Property(
                    type="array",
                    items={
                        "type": "string"
                    },
                    description="ad copies generated by content agent"
                ),
                "emails": Property(
                    type="array",
                    items={
                        "type": "string"
                    },
                    description="email copies generated by content agent"
                ),
                "social_posts": Property(
                    type="array",
                    items={
                        "type": "string"
                    },
                    description="social media posts generated by content agent"
                )
            },
            required=["prompt", "ad_copies", "emails", "social_posts"]
        )
    )
)

CREATIVE_TOOL = Tool(
    type="function",
    function=Function(
        name="image_generation_agent",
        description="generates two images which match the theme of the\
            campaign being generated to serve as the images to follow\
            text content across platforms. File paths returned indicate\
            that generation was successful and will be picked up by the\
            user interface when you send your final response",
        parameters=Parameters(
            type="object",
            properties={
                "prompt": Property(
                    type="string",
                    description="prompt to the stable diffusion model\
                        clearly describing the nature of the image. The\
                        prompt must be less than 200 characters in total"
                ),
                "negative_prompt": Property(
                    type="string",
                    description="negative prompt to the stable diffusion\
                        model stating specific bad outcomes to be avoided\
                        by the model"
                )
            },
            required=["prompt", "negative_prompt"]
        )
    )
)

TASK_SERVICE = TaskService()
ARTIFACT_SERVICE = ArtifactService()


def get_result(
        tool_callables: dict,
        call: ToolCall,
        history: list[Message],
        logger: Logger,
        campaign_id: int,
        chat_id: int | None = None):

    call_arguments = fetch_call_arguments(
        campaign_id=campaign_id,
        chat_id=chat_id,
        call=call
    )

    logger.info(
        "calling tool >> %s with args >> %s",
        call.function.name,
        call_arguments
    )

    task_id = TASK_SERVICE.create(
        CreateTask(
            campaign_id=campaign_id,
            tool_name=call.function.name,
            status="pending",
            output_json=None
        )
    )
    try:
        result = tool_callables[call.function.name](**call_arguments)

        logger.info(
            "result from tool %s >> %s",
            call.function.name,
            result
        )

        validated_result = validate_schema(
            call.function.name,
            result,
            logger
        )
        if task_id:
            if call.function.name == "image_generation_agent":
                TASK_SERVICE.update_by_id(
                    task_id,
                    **{
                        "status": "success",
                        "output_json": {
                            "image_paths": validated_result
                        }
                    }
                )
                validated_result = parse_artifacts(
                    validated_result,
                    task_id,
                    campaign_id
                )
            else:
                TASK_SERVICE.update_by_id(
                    task_id,
                    **{
                        "status": "success",
                        "output_json": validated_result.model_dump(  # noqa # type:ignore
                            mode="json"
                        )
                    }
                )
    except Exception as e:
        logger.error(
            "error calling tool `%s` >> %s << with params >> %s",
            call.function.name,
            e,
            call_arguments
        )
        validated_result = "err calling tool `{}` >> {} << with params >> {}"\
            .format(
                call.function.name,
                e,
                call_arguments
            )
        if task_id:
            TASK_SERVICE.update_by_id(
                task_id,
                **{
                    "status": "error"
                }
            )

    history.append(
        Message(
            role="tool",
            content=str(validated_result),
            tool_name=call.function.name
        )
    )

    return history


def fetch_call_arguments(
        campaign_id: int,
        chat_id: int | None,
        call: ToolCall
        ) -> dict:

    call_arguments: dict = call.function.arguments
    call_arguments["campaign_id"] = str(campaign_id)
    if call.function.name == "image_generation_agent":
        call_arguments["chat_id"] = str(chat_id)
    match call.function.name:
        case "content_agent":
            audience_task = TASK_SERVICE.read_by_camp_id_tool_name(
                campaign_id,
                "audience_agent"
            )
            if audience_task:
                audience_out = AudienceResearchOut.model_validate(
                    audience_task.output_json,
                )
                call_arguments["keywords"] = str(audience_out.keywords)
                call_arguments["interests"] = str(audience_out.interests)
                call_arguments["pain_points"] = str(audience_out.pain_points)
                return call_arguments
            else:
                return call_arguments

        case "scheduler_agent":
            content_task = TASK_SERVICE.read_by_camp_id_tool_name(
                campaign_id,
                "content_agent"
            )
            if content_task:
                content_out = ContentGenOut.model_validate(
                    content_task.output_json
                )
                call_arguments["ad_copies"] = str(content_out.ad_copies)
                call_arguments["emails"] = str(content_out.emails)
                call_arguments["social_posts"] = str(content_out.social_posts)
                return call_arguments
            else:
                return call_arguments
        case _:
            return call_arguments


def validate_schema(function_name: str, result: Any, logger: Logger):
    match function_name:
        case "audience_agent":
            try:
                return AudienceResearchOut.model_validate_json(result)
            except ValidationError:
                logger.error(
                    "schema validation failed. Please call `%s` tool again.",
                    function_name
                )
                return f"Output validation failed. \
                    Please call `{function_name}` tool again."

        case "content_agent":
            try:
                return ContentGenOut.model_validate_json(result)
            except ValidationError:
                logger.error(
                    "schema validation failed. Please call `%s` tool again.",
                    function_name
                )
                return f"Output validation failed. \
                    Please call `{function_name}` tool again."

        case "scheduler_agent":
            try:
                return ScheduleGenOut.model_validate_json(result)
            except ValidationError:
                logger.error(
                    "schema validation failed. Please call `%s` tool again.",
                    function_name
                )
                return f"Output validation failed. \
                    Please call `{function_name}` tool again."
        case _:
            return result


def parse_artifacts(
        validated_result: Any | list,
        task_id: int,
        campaign_id: int
        ):
    if type(validated_result) is list:
        for artifact_path in validated_result:
            _ = ARTIFACT_SERVICE.create(
                CreateArtifact(
                    task_id=task_id,
                    campaign_id=campaign_id,
                    type="image",
                    file_path=artifact_path,
                    version=0
                )
            )
            return str(validated_result)
    else:
        return validated_result
